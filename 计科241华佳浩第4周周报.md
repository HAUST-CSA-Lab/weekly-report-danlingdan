# 计科241 华佳浩 — 第4周周报

**主题：浏览器渲染原理与性能优化**

## 概要
本周重点学习了浏览器渲染流水线、JavaScript 事件循环与异步机制，以及前端构建工具（Webpack 与 Vite）的对比。目标是理解性能瓶颈来源并掌握常用优化手段。

---

## 1. 浏览器渲染流水线

HTML -> DOM Tree

CSS -> CSSOM Tree

DOM + CSSOM -> Render Tree -> Layout（回流）-> Paint（绘制）-> Composite（合成）

说明：Render Tree 只包含可见节点（`display:none` 会被剔除，`visibility:hidden` 会保留占位）。

### 各阶段要点与优化建议

| 阶段 | 底层机制 | 性能影响 | 优化策略 |
| ---- | ---- | ---- | ---- |
| DOM 构建 | HTML 逐字节解析；遇到 `<script>`（非 async/defer）会阻塞解析 | 大型或冗余 DOM 会增加解析时间 | 压缩 HTML，减少 DOM 节点（建议 < 1500），将非关键脚本延后或使用 `async/defer` |
| CSSOM 构建 | CSS 是渲染阻塞资源，需完成 CSSOM 才能生成 Render Tree | 复杂选择器或大量样式增加计算量 | 提取关键样式内联，异步加载非关键 CSS，使用 `media` 限制加载 |
| Render Tree 构建 | 只包含可见节点 | 节点过多增加计算量 | 避免滥用 `visibility`，合理使用 `content-visibility: auto` |
| Layout（回流） | 计算元素位置与大小，是最昂贵的操作 | 频繁触发会严重影响性能 | 避免频繁读写导致的强制同步布局；用 `transform`/`opacity` 替代布局改变 |
| Paint（绘制） | 将渲染树转换为像素 | 大面积或复杂样式（阴影、渐变）成本高 | 避免大量 repaint，减少复杂样式，利用合成层优化 |
| Composite（合成） | GPU 将各层合成最终图像 | 合成层过多会占用显存 | 谨慎使用 `will-change`，防止层爆炸 |

---

## 2. JavaScript 事件循环与异步机制

核心概念：调用栈（同步执行）、Web APIs（浏览器处理异步任务）、任务队列（宏任务与微任务）。

- 宏任务（macrotask）：`setTimeout`、`setInterval`、I/O、UI 渲染。事件循环在每轮清空一个宏任务后会处理微任务队列。
- 微任务（microtask）：`Promise.then`、`queueMicrotask`、`MutationObserver`，优先级高于宏任务，会在当前宏任务结束后立即执行全部微任务。

要点：避免在微任务中做耗时操作以阻塞渲染；合理使用微任务保证异步逻辑的顺序性。

---

## 3. 构建工具对比：Webpack（传统） vs Vite（现代）

| 维度 | Webpack（传统） | Vite（现代） |
| ---- | ---- | ---- |
| 开发模式 | 先打包再提供服务 | 原生 ESM，按需编译，启动快 |
| 冷启动 | 构建完整依赖图，慢 | 按需编译，毫秒级启动 |
| 热更新（HMR） | 重新编译模块及依赖链 | 精确更新，接近原生速度 |
| 底层实现 | 基于 Node.js 的打包 | 依赖预构建用 esbuild（Go 实现，速度快） |
| 生产构建 | 由自身或插件处理 | 使用 Rollup 做生产构建，Tree-shaking 优秀 |




