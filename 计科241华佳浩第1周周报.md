# 学习周报｜pwncollege 汇编 Web Server 挑战


- 主题：使用 x86-64 Linux 汇编完成一个最小可用的 Web Server（GET/POST + 并发）
- 最终产出：`level11.s`（汇编实现）

---

## 1. 目标

1) 熟悉 Linux 网络编程在 **纯系统调用**（syscall）层面的完整链路：`socket → bind → listen → accept`  
2) 用汇编把“HTTP 请求解析 + 文件读写 + 返回响应”串起来，完成 pwncollege 对应挑战  
3) 进一步练习：多连接并发处理、文件描述符管理、缓冲区与字符串解析

---

## 2. 本周完成情况

- [x] 建立监听 socket，并绑定到 `0.0.0.0:80`，开始 listen 
- [x] 主循环 `accept()` 接入客户端连接，并 `fork()` 分成父/子进程（父进程继续 accept，子进程处理请求）fileciteturn1file0L24-L40  
- [x] 子进程读取 HTTP 请求到 buffer，识别首字母区分 `GET` 与 `POST` 
- [x] **GET**：解析路径 → `open` 读取文件 → 回写 `HTTP/1.0 200 OK` 头 + 文件内容  
- [x] **POST**：解析路径 → `open(O_WRONLY|O_CREAT)` → 定位 body → 写入文件 → 回写 `200 OK` 
- [x] 父进程关闭本次连接 fd 并回到 accept 循环 

---

## 3. 关键实现

### 3.1 最小 Web Server 的“系统调用链”长什么样


- 建立 TCP socket：`socket(AF_INET=2, SOCK_STREAM=1, 0)` 
- 绑定地址：`bind(sockfd, &sockaddr_in, 16)` 
- 监听：`listen(sockfd, backlog)` 
- 接入连接：`accept(sockfd, 0, 0)` 

其中 `sockaddr_in` 我直接在 `.data` 段写死：family=2，port=0x5000（小端写入后内存为 `00 50`，等价网络序端口 80），addr=0（0.0.0.0）。

### 3.2 并发模型：fork-per-connection

主进程接入连接后 fork：

- **父进程**：关闭客户端 fd，继续 accept 下一个连接  
- **子进程**：关闭监听 fd，只负责处理当前连接请求 

这种模型很“重”，但对汇编练手非常清晰：不用处理复杂的 IO 多路复用，也能满足题目对并发的要求。

### 3.3 HTTP 解析：只做“够用”的最小解析

- 先 `read(client_fd, buffer, 512)` 把请求读进来，并记录长度 
- 用第一个字节区分 GET/POST（`'G'` vs `'P'`）

#### GET 路径解析

从 `"GET "` 后开始抄字符，直到空格为止（即 `/path`）
拿到路径后 `open` 读文件，再 `write` 回到 socket

#### POST body 定位

为了简单，我用“跳过前 8 行 header”的方式定位 body（不解析 `Content-Length`）  
得到 body 起始偏移后，把剩余内容写入文件

---

## 4. 问题记录

1) **端口字节序（endianness）**
   - `sockaddr_in.sin_port` 是网络字节序；汇编里写 `.2byte 0x5000` 是小端落内存，最终对应网络序 80。
   - 体感：这个坑不踩一次，很难形成“结构体字段 + 字节序”的直觉。

2) **文件描述符假设**
   - 代码里默认 socket fd=3、accept fd=4、open fd=3（关闭后复用）。
   - 这种写法在挑战环境通常可行，但在真实系统上更稳妥的是：**保存 syscall 返回值**，不要写死 fd。

3) **POST body 的通用性**
   - 直接“跳过 8 行”对固定测试用例 OK，但不是真正的 HTTP 解析（更标准的是找 `\r\n\r\n` 或解析 `Content-Length`）。 

---

## 5. 本周收获总结

- 把网络服务的核心逻辑拆成“系统调用原语”的组合：这对做 pwn 里“禁 libc、只给 syscall”的题非常有用。  
- 练出了“汇编字符串解析”的肌肉记忆：指针移动、条件跳转、边界控制。
- 对“并发 ≠ 神秘”有了具象理解：fork 模型虽然粗暴，但概念上很清晰。 

## 6.参考资料
https://x64.syscall.sh/
